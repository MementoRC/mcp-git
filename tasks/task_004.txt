# Task ID: 4
# Title: Implement Flexible Validation with Fallback Handling
# Status: done
# Dependencies: 3
# Priority: high
# Description: Create a robust validation system that can handle unexpected or malformed messages without crashing the server.
# Details:
1. Create a new validation.py module for centralized validation logic
2. Implement try-catch wrappers for Pydantic validation
3. Add fallback validation that extracts critical fields
4. Create logging for validation failures
5. Implement a validation strategy pattern for different message types

```python
# src/mcp_server_git/models/validation.py
import logging
from typing import Dict, Any, Optional, TypeVar, Type, Generic
from pydantic import BaseModel, ValidationError

logger = logging.getLogger(__name__)

T = TypeVar('T', bound=BaseModel)

class ValidationResult(Generic[T]):
    """Container for validation results with error handling."""
    def __init__(self, model: Optional[T] = None, error: Optional[Exception] = None,
                 raw_data: Optional[Dict[str, Any]] = None):
        self.model = model
        self.error = error
        self.raw_data = raw_data or {}
        self.is_valid = model is not None and error is None
    
    @property
    def message_type(self) -> str:
        """Extract message type even if validation failed."""
        if self.model:
            return getattr(self.model, "type", "unknown")
        return self.raw_data.get("type", "unknown")

def validate_message(data: Dict[str, Any], model_class: Type[T]) -> ValidationResult[T]:
    """Validate a message against a model with error handling."""
    try:
        model = model_class.parse_obj(data)
        return ValidationResult(model=model, raw_data=data)
    except ValidationError as e:
        logger.warning(f"Validation error for {model_class.__name__}: {e}")
        return ValidationResult(error=e, raw_data=data)

def safe_parse_notification(data: Dict[str, Any]) -> ValidationResult:
    """Parse a notification with fallback handling."""
    from .notifications import parse_client_notification
    
    try:
        model = parse_client_notification(data)
        return ValidationResult(model=model, raw_data=data)
    except Exception as e:
        logger.error(f"Failed to parse notification: {e}")
        return ValidationResult(error=e, raw_data=data)
```

# Test Strategy:
1. Test validation with valid messages
2. Test with invalid messages to verify error handling
3. Test extraction of critical fields from invalid messages
4. Verify logging of validation errors
5. Test with edge cases (empty messages, missing fields)
6. Benchmark validation performance
