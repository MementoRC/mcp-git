# Task ID: 10
# Title: Enhance Logging and Monitoring
# Status: pending
# Dependencies: 5, 7
# Priority: medium
# Description: Implement comprehensive logging and monitoring to track session health, errors, and performance metrics.
# Details:
1. Create a centralized logging configuration
2. Add structured logging with contextual information
3. Implement performance metrics collection
4. Create health check endpoints
5. Add detailed error logging with context

```python
# src/mcp_server_git/logging_config.py
import logging
import json
import time
from datetime import datetime
from typing import Dict, Any, Optional

class StructuredLogFormatter(logging.Formatter):
    """Formatter that outputs JSON formatted logs."""
    
    def format(self, record: logging.LogRecord) -> str:
        log_data = {
            "timestamp": datetime.fromtimestamp(record.created).isoformat(),
            "level": record.levelname,
            "message": record.getMessage(),
            "logger": record.name,
        }
        
        # Add extra fields from record
        if hasattr(record, "session_id"):
            log_data["session_id"] = record.session_id
        
        if hasattr(record, "request_id"):
            log_data["request_id"] = record.request_id
        
        if hasattr(record, "duration"):
            log_data["duration_ms"] = record.duration
        
        # Add exception info if present
        if record.exc_info:
            log_data["exception"] = {
                "type": record.exc_info[0].__name__,
                "message": str(record.exc_info[1]),
            }
        
        return json.dumps(log_data)

def configure_logging(log_level: str = "INFO") -> None:
    """Configure structured logging."""
    root_logger = logging.getLogger()
    root_logger.setLevel(log_level)
    
    # Remove existing handlers
    for handler in root_logger.handlers:
        root_logger.removeHandler(handler)
    
    # Add console handler with structured formatter
    console_handler = logging.StreamHandler()
    console_handler.setFormatter(StructuredLogFormatter())
    root_logger.addHandler(console_handler)

# src/mcp_server_git/metrics.py
from typing import Dict, List, Any, Optional
import time
import asyncio
from collections import defaultdict

class MetricsCollector:
    """Collects and reports metrics about server operation."""
    
    def __init__(self):
        self.metrics: Dict[str, Any] = {
            "sessions": {
                "active": 0,
                "total_created": 0,
                "errors": 0,
            },
            "messages": {
                "processed": 0,
                "errors": 0,
                "by_type": defaultdict(int),
            },
            "operations": {
                "active": 0,
                "completed": 0,
                "cancelled": 0,
                "failed": 0,
            },
            "performance": {
                "message_processing_time": [],  # Recent processing times in ms
                "avg_processing_time": 0,
            }
        }
        self.lock = asyncio.Lock()
    
    async def record_message(self, message_type: str, duration_ms: float) -> None:
        """Record a processed message."""
        async with self.lock:
            self.metrics["messages"]["processed"] += 1
            self.metrics["messages"]["by_type"][message_type] += 1
            
            # Track performance
            self.metrics["performance"]["message_processing_time"].append(duration_ms)
            # Keep only recent measurements
            if len(self.metrics["performance"]["message_processing_time"]) > 100:
                self.metrics["performance"]["message_processing_time"].pop(0)
            
            # Update average
            times = self.metrics["performance"]["message_processing_time"]
            self.metrics["performance"]["avg_processing_time"] = sum(times) / len(times) if times else 0
    
    async def record_message_error(self, message_type: str) -> None:
        """Record a message processing error."""
        async with self.lock:
            self.metrics["messages"]["errors"] += 1
    
    async def record_session_created(self) -> None:
        """Record a new session creation."""
        async with self.lock:
            self.metrics["sessions"]["active"] += 1
            self.metrics["sessions"]["total_created"] += 1
    
    async def record_session_closed(self) -> None:
        """Record a session being closed."""
        async with self.lock:
            self.metrics["sessions"]["active"] -= 1
    
    async def record_operation_started(self) -> None:
        """Record an operation being started."""
        async with self.lock:
            self.metrics["operations"]["active"] += 1
    
    async def record_operation_completed(self, cancelled: bool = False, failed: bool = False) -> None:
        """Record an operation being completed."""
        async with self.lock:
            self.metrics["operations"]["active"] -= 1
            
            if cancelled:
                self.metrics["operations"]["cancelled"] += 1
            elif failed:
                self.metrics["operations"]["failed"] += 1
            else:
                self.metrics["operations"]["completed"] += 1
    
    async def get_metrics(self) -> Dict[str, Any]:
        """Get a copy of the current metrics."""
        async with self.lock:
            return dict(self.metrics)

# Add performance tracking to server.py
async def process_message(self, raw_message: Dict[str, Any], session_id: str) -> None:
    """Process an incoming message with performance tracking."""
    start_time = time.time()
    message_type = raw_message.get("type", "unknown")
    
    try:
        # ... existing message processing code ...
        
        # Record metrics
        duration_ms = (time.time() - start_time) * 1000
        await self.metrics.record_message(message_type, duration_ms)
        
        # Add performance info to logs
        logger.info(f"Processed {message_type} message", extra={
            "session_id": session_id,
            "duration": duration_ms,
            "message_type": message_type
        })
        
    except Exception as e:
        # Record error in metrics
        await self.metrics.record_message_error(message_type)
        
        # ... existing error handling code ...
```

# Test Strategy:
1. Verify structured logs contain all required fields
2. Test metrics collection for different operations
3. Verify performance tracking accuracy
4. Test concurrent metrics updates
5. Verify error logging captures all necessary context
6. Test log levels and filtering
