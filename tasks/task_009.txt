# Task ID: 9
# Title: Update Server Message Handling for Cancellation
# Status: pending
# Dependencies: 3, 4, 7
# Priority: high
# Description: Modify the server's message handling to properly process cancellation notifications and maintain session stability.
# Details:
1. Update the main message handling loop in server.py
2. Add specific handling for cancellation notifications
3. Implement operation cancellation logic
4. Add error recovery for message processing
5. Update session state based on message outcomes

```python
# src/mcp_server_git/server.py
import asyncio
import logging
from typing import Dict, Any, Optional, List

from .models.notifications import parse_client_notification, CancelledNotification
from .models.validation import validate_message, ValidationResult
from .error_handling import handle_error, ErrorContext, ErrorSeverity, recoverable
from .session import SessionManager, Session

logger = logging.getLogger(__name__)

class MCPGitServer:
    # ... existing initialization code ...
    
    @recoverable(max_retries=3)
    async def process_message(self, raw_message: Dict[str, Any], session_id: str) -> None:
        """Process an incoming message with error handling."""
        session = await self.session_manager.get_session(session_id)
        if not session:
            logger.warning(f"Message received for unknown session {session_id}")
            return
        
        session.record_message()
        
        try:
            # Validate the message
            validation_result = validate_message(raw_message, self.get_model_for_message_type(raw_message))
            
            if not validation_result.is_valid:
                # Handle validation failure
                logger.warning(f"Invalid message format: {validation_result.error}")
                # Continue processing with best effort if possible
            
            # Process based on message type
            message_type = validation_result.message_type
            
            if message_type == "notifications/cancelled":
                await self.handle_cancellation(validation_result, session)
            elif message_type == "heartbeat":
                await self.handle_heartbeat(raw_message, session_id)
            else:
                # Handle other message types
                await self.handle_standard_message(validation_result, session)
                
        except Exception as e:
            # Create error context
            context = ErrorContext(
                error=e,
                severity=self.determine_error_severity(e),
                operation="process_message",
                session_id=session_id,
                recoverable=True,
                metadata={"message_type": raw_message.get("type", "unknown")}
            )
            
            # Handle the error
            recovered = await handle_error(context)
            if not recovered and session:
                session.state = SessionState.ERROR
    
    async def handle_cancellation(self, validation_result: ValidationResult, session: Session) -> None:
        """Handle a cancellation notification."""
        if validation_result.is_valid and isinstance(validation_result.model, CancelledNotification):
            # Get the properly validated model
            notification = validation_result.model
            request_id = notification.request_id
            
            logger.info(f"Received cancellation for request {request_id} in session {session.session_id}")
            
            # Remove from active operations
            session.remove_operation(request_id)
            
            # Cancel any ongoing tasks for this request
            if request_id in self.active_tasks:
                task = self.active_tasks[request_id]
                if not task.done():
                    logger.info(f"Cancelling task for request {request_id}")
                    task.cancel()
                del self.active_tasks[request_id]
        else:
            # Use the raw data as fallback
            raw_data = validation_result.raw_data
            request_id = raw_data.get("request_id", "unknown")
            
            logger.warning(f"Processing invalid cancellation for request {request_id} with best effort")
            
            # Best effort cancellation using raw data
            if request_id != "unknown" and request_id in self.active_tasks:
                task = self.active_tasks[request_id]
                if not task.done():
                    task.cancel()
                del self.active_tasks[request_id]
                session.remove_operation(request_id)
    
    def determine_error_severity(self, error: Exception) -> ErrorSeverity:
        """Determine the severity of an error."""
        # Classify errors by type
        if isinstance(error, asyncio.CancelledError):
            return ErrorSeverity.LOW  # Normal cancellation
        
        if isinstance(error, ValueError) or isinstance(error, TypeError):
            return ErrorSeverity.MEDIUM  # Validation errors
        
        # Default to high for unknown errors
        return ErrorSeverity.HIGH
```

# Test Strategy:
1. Test handling of valid cancellation notifications
2. Test with malformed cancellation messages
3. Verify active operations are properly cancelled
4. Test error recovery during message processing
5. Verify session state is maintained correctly
6. Test with concurrent messages and cancellations
